{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = wrapConnectorHooks;\nvar _react = require('react');\nvar _cloneWithRef = require('./utils/cloneWithRef');\nvar _cloneWithRef2 = _interopRequireDefault(_cloneWithRef);\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction throwIfCompositeComponentElement(element) {\n  // Custom components can no longer be wrapped directly in React DnD 2.0\n  // so that we don't need to depend on findDOMNode() from react-dom.\n  if (typeof element.type === 'string') {\n    return;\n  }\n  var displayName = element.type.displayName || element.type.name || 'the component';\n  throw new Error('Only native element nodes can now be passed to React DnD connectors.' + ('You can either wrap ' + displayName + ' into a <div>, or turn it into a ') + 'drag source or a drop target itself.');\n}\nfunction wrapHookToRecognizeElement(hook) {\n  return function () {\n    var elementOrNode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n    // When passed a node, call the hook straight away.\n    if (!(0, _react.isValidElement)(elementOrNode)) {\n      var node = elementOrNode;\n      hook(node, options);\n      return undefined;\n    }\n\n    // If passed a ReactElement, clone it and attach this function as a ref.\n    // This helps us achieve a neat API where user doesn't even know that refs\n    // are being used under the hood.\n    var element = elementOrNode;\n    throwIfCompositeComponentElement(element);\n\n    // When no options are passed, use the hook directly\n    var ref = options ? function (node) {\n      return hook(node, options);\n    } : hook;\n    return (0, _cloneWithRef2.default)(element, ref);\n  };\n}\nfunction wrapConnectorHooks(hooks) {\n  var wrappedHooks = {};\n  Object.keys(hooks).forEach(function (key) {\n    var hook = hooks[key];\n    var wrappedHook = wrapHookToRecognizeElement(hook);\n    wrappedHooks[key] = function () {\n      return wrappedHook;\n    };\n  });\n  return wrappedHooks;\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","default","wrapConnectorHooks","_react","require","_cloneWithRef","_cloneWithRef2","_interopRequireDefault","obj","__esModule","throwIfCompositeComponentElement","element","type","displayName","name","Error","wrapHookToRecognizeElement","hook","elementOrNode","arguments","length","undefined","options","isValidElement","node","ref","hooks","wrappedHooks","keys","forEach","key","wrappedHook"],"sources":["C:/Users/osqel/OneDrive/Desktop/New folder/node_modules/react-dnd/lib/wrapConnectorHooks.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\nexports.default = wrapConnectorHooks;\n\nvar _react = require('react');\n\nvar _cloneWithRef = require('./utils/cloneWithRef');\n\nvar _cloneWithRef2 = _interopRequireDefault(_cloneWithRef);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction throwIfCompositeComponentElement(element) {\n\t// Custom components can no longer be wrapped directly in React DnD 2.0\n\t// so that we don't need to depend on findDOMNode() from react-dom.\n\tif (typeof element.type === 'string') {\n\t\treturn;\n\t}\n\n\tvar displayName = element.type.displayName || element.type.name || 'the component';\n\n\tthrow new Error('Only native element nodes can now be passed to React DnD connectors.' + ('You can either wrap ' + displayName + ' into a <div>, or turn it into a ') + 'drag source or a drop target itself.');\n}\n\nfunction wrapHookToRecognizeElement(hook) {\n\treturn function () {\n\t\tvar elementOrNode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\t\tvar options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\n\t\t// When passed a node, call the hook straight away.\n\t\tif (!(0, _react.isValidElement)(elementOrNode)) {\n\t\t\tvar node = elementOrNode;\n\t\t\thook(node, options);\n\t\t\treturn undefined;\n\t\t}\n\n\t\t// If passed a ReactElement, clone it and attach this function as a ref.\n\t\t// This helps us achieve a neat API where user doesn't even know that refs\n\t\t// are being used under the hood.\n\t\tvar element = elementOrNode;\n\t\tthrowIfCompositeComponentElement(element);\n\n\t\t// When no options are passed, use the hook directly\n\t\tvar ref = options ? function (node) {\n\t\t\treturn hook(node, options);\n\t\t} : hook;\n\n\t\treturn (0, _cloneWithRef2.default)(element, ref);\n\t};\n}\n\nfunction wrapConnectorHooks(hooks) {\n\tvar wrappedHooks = {};\n\n\tObject.keys(hooks).forEach(function (key) {\n\t\tvar hook = hooks[key];\n\t\tvar wrappedHook = wrapHookToRecognizeElement(hook);\n\t\twrappedHooks[key] = function () {\n\t\t\treturn wrappedHook;\n\t\t};\n\t});\n\n\treturn wrappedHooks;\n}"],"mappings":"AAAA,YAAY;;AAEZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAC5CC,KAAK,EAAE;AACR,CAAC,CAAC;AACFD,OAAO,CAACE,OAAO,GAAGC,kBAAkB;AAEpC,IAAIC,MAAM,GAAGC,OAAO,CAAC,OAAO,CAAC;AAE7B,IAAIC,aAAa,GAAGD,OAAO,CAAC,sBAAsB,CAAC;AAEnD,IAAIE,cAAc,GAAGC,sBAAsB,CAACF,aAAa,CAAC;AAE1D,SAASE,sBAAsBA,CAACC,GAAG,EAAE;EAAE,OAAOA,GAAG,IAAIA,GAAG,CAACC,UAAU,GAAGD,GAAG,GAAG;IAAEP,OAAO,EAAEO;EAAI,CAAC;AAAE;AAE9F,SAASE,gCAAgCA,CAACC,OAAO,EAAE;EAClD;EACA;EACA,IAAI,OAAOA,OAAO,CAACC,IAAI,KAAK,QAAQ,EAAE;IACrC;EACD;EAEA,IAAIC,WAAW,GAAGF,OAAO,CAACC,IAAI,CAACC,WAAW,IAAIF,OAAO,CAACC,IAAI,CAACE,IAAI,IAAI,eAAe;EAElF,MAAM,IAAIC,KAAK,CAAC,sEAAsE,IAAI,sBAAsB,GAAGF,WAAW,GAAG,mCAAmC,CAAC,GAAG,sCAAsC,CAAC;AAChN;AAEA,SAASG,0BAA0BA,CAACC,IAAI,EAAE;EACzC,OAAO,YAAY;IAClB,IAAIC,aAAa,GAAGC,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKE,SAAS,GAAGF,SAAS,CAAC,CAAC,CAAC,GAAG,IAAI;IAC5F,IAAIG,OAAO,GAAGH,SAAS,CAACC,MAAM,GAAG,CAAC,IAAID,SAAS,CAAC,CAAC,CAAC,KAAKE,SAAS,GAAGF,SAAS,CAAC,CAAC,CAAC,GAAG,IAAI;;IAEtF;IACA,IAAI,CAAC,CAAC,CAAC,EAAEhB,MAAM,CAACoB,cAAc,EAAEL,aAAa,CAAC,EAAE;MAC/C,IAAIM,IAAI,GAAGN,aAAa;MACxBD,IAAI,CAACO,IAAI,EAAEF,OAAO,CAAC;MACnB,OAAOD,SAAS;IACjB;;IAEA;IACA;IACA;IACA,IAAIV,OAAO,GAAGO,aAAa;IAC3BR,gCAAgC,CAACC,OAAO,CAAC;;IAEzC;IACA,IAAIc,GAAG,GAAGH,OAAO,GAAG,UAAUE,IAAI,EAAE;MACnC,OAAOP,IAAI,CAACO,IAAI,EAAEF,OAAO,CAAC;IAC3B,CAAC,GAAGL,IAAI;IAER,OAAO,CAAC,CAAC,EAAEX,cAAc,CAACL,OAAO,EAAEU,OAAO,EAAEc,GAAG,CAAC;EACjD,CAAC;AACF;AAEA,SAASvB,kBAAkBA,CAACwB,KAAK,EAAE;EAClC,IAAIC,YAAY,GAAG,CAAC,CAAC;EAErB9B,MAAM,CAAC+B,IAAI,CAACF,KAAK,CAAC,CAACG,OAAO,CAAC,UAAUC,GAAG,EAAE;IACzC,IAAIb,IAAI,GAAGS,KAAK,CAACI,GAAG,CAAC;IACrB,IAAIC,WAAW,GAAGf,0BAA0B,CAACC,IAAI,CAAC;IAClDU,YAAY,CAACG,GAAG,CAAC,GAAG,YAAY;MAC/B,OAAOC,WAAW;IACnB,CAAC;EACF,CAAC,CAAC;EAEF,OAAOJ,YAAY;AACpB","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}